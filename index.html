<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Product Cut Sheets & Certifications – Static Manager</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
  <script>
    // Lightweight toast notifications
    function showToast(msg, type='info'){
      let el=document.getElementById('toast');
      if(!el){ el=document.createElement('div'); el.id='toast'; el.className='fixed bottom-4 right-4 z-50 max-w-sm'; document.body.appendChild(el);} 
      const box=document.createElement('div');
      box.className=`mb-2 px-3 py-2 rounded-xl shadow text-sm ${type==='error'?'bg-red-600 text-white':type==='success'?'bg-green-600 text-white':'bg-gray-900 text-white'}`;
      box.textContent=msg; el.appendChild(box); setTimeout(()=>box.remove(), 4000);
    }
  </script>
  <style>
    .line-clamp-2 { display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    details[open] summary::after { content: "▲"; margin-left: .5rem; font-size: .75rem; }
    details summary::after { content: "▼"; margin-left: .5rem; font-size: .75rem; }
  </style>
</head>
<body class="bg-gray-50 text-gray-900">
  <div class="max-w-7xl mx-auto p-6">
    <header class="flex items-center justify-between mb-6">
      <h1 class="text-2xl font-semibold">Product Cut Sheets & Certifications (Static)</h1>
      <nav class="flex items-center gap-2 text-sm">
        <button id="exportJsonBtn" class="px-3 py-2 rounded-xl bg-white shadow hover:shadow-md">Export JSON</button>
        <label class="px-3 py-2 rounded-xl bg-white shadow hover:shadow-md cursor-pointer">
          Import JSON<input id="importJson" type="file" accept="application/json" class="hidden">
        </label>
        <button id="clearAllBtn" class="px-3 py-2 rounded-xl bg-red-600 text-white">Clear All</button>
      </nav>
    </header>

    <section class="bg-white rounded-2xl shadow p-6 mb-6">
      <h2 class="text-lg font-medium mb-4">Add / Edit Product</h2>
      <form id="productForm" class="space-y-4">
        <input type="hidden" id="editId" value="">
        <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
          <div>
            <label class="block text-sm text-gray-600">Name *</label>
            <input id="name" required class="px-3 py-2 rounded-xl border w-full" />
          </div>
          <div>
            <label class="block text-sm text-gray-600">Product Image (PNG/JPG)</label>
            <input id="photo" type="file" accept="image/png,image/jpeg" class="block w-full text-sm text-gray-600" />
            <div class="mt-2 flex items-center gap-2">
              <img id="photoPreview" alt="preview" class="w-12 h-12 object-cover rounded-lg border hidden" />
              <span class="text-xs text-gray-500">Optional preview</span>
            </div>
          </div>
          <div>
            <label class="block text-sm text-gray-600">Model Number</label>
            <input id="model" class="px-3 py-2 rounded-xl border w-full" />
          </div>
          <div>
            <label class="block text-sm text-gray-600">Power / Output</label>
            <div class="grid grid-cols-2 gap-2">
              <div class="flex items-center gap-2">
                <label for="watt" class="text-sm text-gray-600 whitespace-nowrap">Watt</label>
                <input id="watt" type="number" min="0" step="1" class="px-3 py-2 rounded-xl border w-full" />
              </div>
              <div class="flex items-center gap-2">
                <label for="lumen" class="text-sm text-gray-600 whitespace-nowrap">Lumen</label>
                <input id="lumen" type="number" min="0" step="1" class="px-3 py-2 rounded-xl border w-full" />
              </div>
            </div>
          </div>
        </div>
        <div>
          <label class="block text-sm text-gray-600">Equipment Type</label>
          <select id="eqType" class="px-3 py-2 rounded-xl border w-full">
            <option value="">Select Equipment Type</option>
            <option value="Strip Lights">Strip Lights</option>
            <option value="Wall Packs">Wall Packs</option>
            <option value="Floodlights">Floodlights</option>
            <option value="Flat Panels">Flat Panels</option>
            <option value="Troffer Lights">Troffer Lights</option>
            <option value="Backlit Panels">Backlit Panels</option>
            <option value="T8_LED Linear Lamps">T8_LED Linear Lamps</option>
            <option value="Highbays">Highbays</option>
            <option value="Top Posts">Top Posts</option>
            <option value="Pole Lights">Pole Lights</option>
            <option value="Downlights">Downlights</option>
            <option value="Sensors">Sensors</option>
            <option value="Canopy Lights">Canopy Lights</option>
            <option value="Others">Others</option>
          </select>
        </div>
        <div>
          <label class="block text-sm text-gray-600">Notes</label>
          <textarea id="notes" rows="3" class="px-3 py-2 rounded-xl border w-full"></textarea>
        </div>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <label class="block text-sm text-gray-600">Cutsheet (PDF)</label>
            <input id="cutsheet" type="file" accept="application/pdf" class="block w-full text-sm text-gray-600" />
            <p class="text-xs text-gray-500 mt-1">Optional on create; can add later. Must be a PDF.</p>
          </div>
          <div>
            <label class="block text-sm text-gray-600">Certification (PNG/JPG/PDF)</label>
            <input id="cert" type="file" accept="image/png,image/jpeg,application/pdf" class="block w-full text-sm text-gray-600" />
            <p class="text-xs text-gray-500 mt-1">Image (png/jpg) or PDF. Images will be converted to PDF for combined downloads.</p>
          </div>
        </div>
        <div class="flex items-center gap-2">
          <button class="px-4 py-2 rounded-xl bg-blue-600 text-white hover:bg-blue-700">Save</button>
          <button id="cancelEdit" type="button" class="px-4 py-2 rounded-xl bg-white border">Cancel</button>
        </div>
      </form>
    </section>

    <section class="bg-white rounded-2xl shadow overflow-hidden">
      <div class="flex items-center justify-between px-4 py-3 border-b">
        <div class="text-sm text-gray-600">Manage your products below. Files are stored locally in your browser (no server).</div>
        <div class="flex items-center gap-2">
          <input type="text" id="search" placeholder="Search..." class="px-3 py-2 rounded-xl border w-56" />
          <select id="typeFilter" class="px-3 py-2 rounded-xl border">
            <option value="">Filter: All Types</option>
            <option value="Strip Lights">Strip Lights</option>
            <option value="Wall Packs">Wall Packs</option>
            <option value="Floodlights">Floodlights</option>
            <option value="Flat Panels">Flat Panels</option>
            <option value="Troffer Lights">Troffer Lights</option>
            <option value="Backlit Panels">Backlit Panels</option>
            <option value="T8_LED Linear Lamps">T8_LED Linear Lamps</option>
            <option value="Highbays">Highbays</option>
            <option value="Top Posts">Top Posts</option>
            <option value="Pole Lights">Pole Lights</option>
            <option value="Downlights">Downlights</option>
            <option value="Sensors">Sensors</option>
            <option value="Canopy Lights">Canopy Lights</option>
            <option value="Others">Others</option>
          </select>
        </div>
      </div>

      <!-- Bulk actions toolbar -->
      <div class="flex flex-wrap items-center gap-2 px-4 py-3 border-b bg-gray-50">
        <div class="text-sm text-gray-600 mr-2"><span id="selCount">0</span> selected</div>
        <button id="bulkCutsheets" class="px-3 py-2 rounded-xl bg-white border disabled:opacity-50" disabled>Download Selected Cutsheets</button>
        <button id="bulkCerts" class="px-3 py-2 rounded-xl bg-white border disabled:opacity-50" disabled>Download Selected Certs</button>
        <button id="bulkCombined" class="px-3 py-2 rounded-xl bg-gray-900 text-white disabled:opacity-50" disabled>Download Selected Combined</button>
      </div>

      <div class="overflow-x-auto">
        <table class="w-full text-sm">
          <thead class="bg-gray-100">
            <tr class="text-left">
              <th class="p-3 w-10"><input id="selAll" type="checkbox" class="w-4 h-4"></th>
              <th class="p-3">Name</th>
              <th class="p-3">Model</th>
              <th class="p-3">Type</th>
              <th class="p-3">Cutsheet</th>
              <th class="p-3">Certification</th>
              <th class="p-3 text-right">Actions</th>
            </tr>
          </thead>
          <tbody id="rows"></tbody>
        </table>
      </div>
    </section>

    <details class="mt-6 bg-white rounded-2xl shadow p-4">
      <summary class="cursor-pointer select-none text-sm text-gray-700">Dev / Tests</summary>
      <div class="mt-3 space-y-3 text-sm">
        <div class="text-gray-600">Run a few sanity tests (no network, in-browser only). Results appear below.</div>
        <button id="runTests" class="px-3 py-2 rounded-xl bg-white border">Run Tests</button>
        <pre id="testLog" class="mt-2 p-3 bg-gray-50 border rounded-xl whitespace-pre-wrap text-xs"></pre>
      </div>
    </details>

    <footer class="mt-10 text-sm text-gray-500">&copy; <span id="y"></span> Static Product Docs Manager</footer>
  </div>
  
  <!-- --- ADDED IMAGE MODAL HERE TO BE ABOVE THE SCRIPT --- -->
  <div id="imageModal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4 hidden">
    <div class="relative bg-white p-4 rounded-xl shadow-xl max-w-4xl max-h-full overflow-auto">
      <button id="closeModal" class="absolute -top-3 -right-3 w-8 h-8 bg-red-600 text-white rounded-full flex items-center justify-center shadow-lg text-2xl leading-none" aria-label="Close">&times;</button>
      <img id="modalImage" src="" alt="Enlarged Product Image" class="max-w-full max-h-[80vh] object-contain">
    </div>
  </div>
  <!-- --- END IMAGE MODAL --- -->

  <script>
    // =============================
    // Helpers, Storage & Binary
    // =============================
    function escapeHtml(s){
      return String(s||'')
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;')
        .replace(/'/g,'&#39;');
    }

    async function tryNativeSave(blob, suggestedName){
      if (typeof window.showSaveFilePicker !== 'function') return false;
      try{
        const handle = await window.showSaveFilePicker({ suggestedName, types: [
          { description: 'PDF', accept: { 'application/pdf': ['.pdf'] } },
          { description: 'JSON', accept: { 'application/json': ['.json'] } },
          { description: 'All Files', accept: { '*/*': ['.*'] } }
        ] });
        const writable = await handle.createWritable();
        await writable.write(blob);
        await writable.close();
        showToast(`Saved ${suggestName}`,'success');
        return true;
      }catch(err){ return false; }
    }

    const LS_KEY = 'product_docs_v1'; // Old localStorage key
    const DB_NAME = 'product_docs_v1_idb';
    const STORE_NAME = 'products';
    const MIGRATION_KEY = 'product_docs_migrated_v1';

    const $ = (sel) => document.querySelector(sel);
    const $$ = (sel) => Array.from(document.querySelectorAll(sel));

    // --- IndexedDB Wrapper ---
    let dbPromise = null;
    function initDB() {
      if (dbPromise) return dbPromise;
      dbPromise = new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, 1);
        request.onerror = (e) => { console.error('IDB Error', e); reject('Error opening DB'); };
        request.onsuccess = (e) => resolve(e.target.result);
        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            db.createObjectStore(STORE_NAME, { keyPath: 'id' });
          }
        };
      });
      return dbPromise;
    }

    async function getAllProducts() {
      const db = await initDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_NAME, 'readonly');
        const store = tx.objectStore(STORE_NAME);
        const request = store.getAll();
        request.onsuccess = () => resolve(request.result);
        request.onerror = (e) => { console.error(e); reject('Failed to get all products'); };
      });
    }

    async function saveProduct(product) {
      const db = await initDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_NAME, 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        const request = store.put(product);
        request.onsuccess = () => resolve(request.result);
        request.onerror = (e) => { console.error(e); reject('Failed to save product'); };
      });
    }

    async function deleteProduct(id) {
      const db = await initDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_NAME, 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        const request = store.delete(id);
        request.onsuccess = () => resolve();
        request.onerror = (e) => { console.error(e); reject('Failed to delete product'); };
      });
    }

    async function clearAllProducts() {
      const db = await initDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_NAME, 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        const request = store.clear();
        request.onsuccess = () => resolve();
        request.onerror = (e) => { console.error(e); reject('Failed to clear products'); };
      });
    }
    
    async function importProducts(products) {
      const db = await initDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_NAME, 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        let count = 0;
        
        // --- CHANGE: Removed store.clear() to merge data instead of replacing ---
        // After clearing, add all new products
        if (products.length === 0) {
            resolve();
            return;
        }
        products.forEach(p => {
            // Use 'put' to upsert (update if ID exists, insert if not)
            const putRequest = store.put(p);
            putRequest.onsuccess = () => {
                count++;
                if (count === products.length) {
                    resolve();
                }
            };
            putRequest.onerror = (e) => {
                console.warn('Failed to import/update product:', p.id, e);
                // Continue trying to import others
                count++;
                if (count === products.length) {
                    resolve();
                }
            };
        });
        // --- END CHANGE ---
      });
    }

    // --- End IndexedDB Wrapper ---


    function readFileAsDataURL(file) {
      return new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onload = () => resolve(fr.result);
        fr.onerror = reject;
        fr.readAsDataURL(file);
      });
    }

    function dataURLToBlob(dataUrl){
      const match = /^data:([^;]+);base64,(.*)$/.exec(dataUrl || '');
      if(!match) throw new Error('Invalid data URL');
      const mime = match[1] || 'application/octet-stream';
      const b64 = match[2] || '';
      const chunk = 4 * Math.ceil((1024*64)/3);
      const parts = [];
      for (let i=0; i<b64.length; i+=chunk){
        const bin = atob(b64.slice(i, i+chunk));
        const bytes = new Uint8Array(bin.length);
        for (let j=0;j<bin.length;j++) bytes[j] = bin.charCodeAt(j);
        parts.push(bytes);
      }
      return new Blob(parts, { type: mime });
    }
    function dataURLToArrayBuffer(dataUrl){ return dataURLToBlob(dataUrl).arrayBuffer(); }

    function legacyBase64ToArrayBuffer(b64) {
      const bin = atob(b64);
      const len = bin.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) bytes[i] = bin.charCodeAt(i);
      return bytes.buffer;
    }

    function humanLabel(p) { return (p.model || p.name || 'product').replace(/[\\/]/g, '-'); }
    
    // This function is ONLY for the one-time migration
    function _legacyLoadAllFromLocalStorage() { try { return JSON.parse(localStorage.getItem(LS_KEY) || '[]'); } catch { return []; } }
    
    function normalizeProduct(p){
        if (!p.id){ p.id = (window.crypto?.randomUUID?.() || String(Date.now()+Math.random())); }
        if (!('created_at' in p)) { p.created_at = Date.now(); }
        if (!('updated_at' in p)) { p.updated_at = p.created_at; }
        return p;
    }

    // Selection state
    const selectedIds = new Set();
    function updateBulkUI(){
      const count = selectedIds.size;
      $('#selCount').textContent = String(count);
      const any = count > 0;
      $('#bulkCutsheets').disabled = !any;
      $('#bulkCerts').disabled = !any;
      $('#bulkCombined').disabled = !any;
      const allVisibleIds = $$('#rows input[type="checkbox"][data-id]').map(x=>x.getAttribute('data-id'));
      const allSelectedVisible = allVisibleIds.length>0 && allVisibleIds.every(id=>selectedIds.has(id));
      $('#selAll').checked = allSelectedVisible;
      $('#selAll').indeterminate = !allSelectedVisible && count>0;
    }

    // =============================
    // Render
    // =============================
    function render(list) {
      const q = $('#search').value.trim().toLowerCase();
      const rows = $('#rows');
      rows.innerHTML = '';
      list
        .filter(p => {
          const matchesQuery = !q || [p.name, p.model, p.type, p.notes].some(x => String(x||'').toLowerCase().includes(q));
          const tf = document.getElementById('typeFilter')?.value || '';
          const matchesType = !tf || (p.type||'') === tf;
          return matchesQuery && matchesType;
        })
        .sort((a,b) => (b.created_at||0)-(a.created_at||0))
        .forEach(p => {
          const tr = document.createElement('tr');
          tr.className = 'border-t align-top';
          const hasCS = !!(p.cutsheet && (p.cutsheet.dataUrl || p.cutsheet.data64));
          const hasCT = !!(p.cert && (p.cert.dataUrl || p.cert.data64));
          const checked = selectedIds.has(p.id) ? 'checked' : '';

          const wattLumen = (p.watt||p.lumen)
            ? '<div class="text-xs text-gray-500 mt-1">' + (p.watt?escapeHtml(p.watt)+' W':'') + (p.watt&&p.lumen?' · ':'') + (p.lumen?escapeHtml(p.lumen)+' lm':'') + '</div>'
            : '';
          const notesHtml = p.notes ? "<div class='text-gray-500 line-clamp-2 max-w-xs'>"+escapeHtml(p.notes)+"</div>" : '';
          const cutsheetBadge = hasCS
            ? '<span class="inline-flex items-center px-2 py-1 rounded-full bg-green-100 text-green-700">Present</span>'
            : '<span class="inline-flex items-center px-2 py-1 rounded-full bg-red-100 text-red-700">Missing</span>';
          const certBadge = hasCT
            ? '<span class="inline-flex items-center px-2 py-1 rounded-full bg-green-100 text-green-700">Present</span>'
            : '<span class="inline-flex items-center px-2 py-1 rounded-full bg-red-100 text-red-700">Missing</span>';

          tr.innerHTML =
            '<td class="p-3 w-10"><input type="checkbox" class="rowSel w-4 h-4" data-id="'+p.id+'" '+checked+'></td>'+
            '<td class="p-3">'+
              '<div class="flex items-center gap-2">'+
                '<img src="'+(p.image?.dataUrl||'')+'" class="'+(p.image?.dataUrl?'cursor-pointer':'hidden')+' w-8 h-8 object-cover rounded-md border" alt="thumb" data-act="view-img" data-id="'+p.id+'">'+
                '<div class="font-medium">'+escapeHtml(p.name||'')+'</div>'+ 
              '</div>'+ wattLumen + notesHtml +
            '</td>'+
            '<td class="p-3">'+escapeHtml(p.model||'—')+'</td>'+
            '<td class="p-3">'+escapeHtml(p.type||'—')+'</td>'+
            '<td class="p-3">'+cutsheetBadge+'</td>'+
            '<td class="p-3">'+certBadge+'</td>'+
            '<td class="p-3 text-right">'+
              '<div class="flex justify-end gap-2 flex-wrap">'+
                '<button class="px-3 py-2 rounded-xl bg-white border hover:bg-gray-50" data-act="edit" data-id="'+p.id+'">Edit</button>'+
                '<button class="px-3 py-2 rounded-xl bg-white border hover:bg-gray-50" data-act="dl-cs" data-id="'+p.id+'" '+(hasCS?'':'disabled')+'>Download Cutsheet</button>'+
                '<button class="px-3 py-2 rounded-xl bg-white border hover:bg-gray-50" data-act="dl-cert" data-id="'+p.id+'" '+(hasCT?'':'disabled')+'>Download Cert</button>'+
                '<button class="px-3 py-2 rounded-xl bg-gray-900 text-white" data-act="dl-combined" data-id="'+p.id+'" '+(hasCS&&hasCT?'':'disabled')+'>Combined PDF</button>'+
                '<button class="px-3 py-2 rounded-xl bg-red-600 text-white" data-act="del" data-id="'+p.id+'">Delete</button>'+
              '</div>'+
            '</td>';
          rows.appendChild(tr);
        });
      updateBulkUI();
    }

    function resetForm() { 
      $('#editId').value = ''; 
      $('#productForm').reset(); 
      const img=$('#photoPreview'); if (img){ img.src=''; img.classList.add('hidden'); }
    }

    // =============================
    // CRUD + Downloads
    // =============================
    async function handleSave(e) {
      e.preventDefault();
      const name = $('#name').value.trim();
      if (!name) { showToast('Name is required', 'error'); return; }
      const model = $('#model').value.trim();
      const notes = $('#notes').value.trim();
      const type = $('#eqType')?.value || '';
      const watt = $('#watt')?.value.trim() || '';
      const lumen = $('#lumen')?.value.trim() || '';
      const csFile = $('#cutsheet').files[0];
      const ctFile = $('#cert').files[0];
      const photoFile = $('#photo') ? $('#photo').files[0] : null;

      const idEditing = $('#editId').value;
      let p = null;
      if (idEditing) {
        const allProducts = await getAllProducts();
        p = allProducts.find(x => x.id === idEditing);
      }
      
      if (!p) { 
        p = { id: crypto.randomUUID(), created_at: Date.now() }; 
      } else {
        // Preserve existing files if new ones aren't uploaded
        if (!csFile && p.cutsheet) { /* keep p.cutsheet */ }
        if (!ctFile && p.cert) { /* keep p.cert */ }
        if (!photoFile && p.image) { /* keep p.image */ }
      }
      
      p.name = name; p.model = model; p.notes = notes; p.type = type; p.watt = watt; p.lumen = lumen; p.updated_at = Date.now();
      p = normalizeProduct(p); // Ensure timestamps/id exist

      if (csFile) {
        if (csFile.type !== 'application/pdf') { showToast('Cutsheet must be a PDF.', 'error'); return; }
        const dataUrl = await readFileAsDataURL(csFile);
        p.cutsheet = { filename: csFile.name, mime: csFile.type, dataUrl };
      }
      if (ctFile) {
        if (!['application/pdf','image/png','image/jpeg'].includes(ctFile.type)) { showToast('Certification must be a PDF or PNG/JPG.', 'error'); return; }
        const dataUrl = await readFileAsDataURL(ctFile);
        p.cert = { filename: ctFile.name, mime: ctFile.type, dataUrl };
      }
      if (photoFile) {
        if (!['image/png','image/jpeg'].includes(photoFile.type)) { showToast('Product image must be PNG or JPG.', 'error'); return; }
        const dataUrl = await readFileAsDataURL(photoFile);
        p.image = { filename: photoFile.name, mime: photoFile.type, dataUrl };
      }

      await saveProduct(p);
      render(await getAllProducts());
      resetForm();
      showToast(idEditing ? 'Product updated' : 'Product saved', 'success');
    }

    async function startEdit(id) {
      const allProducts = await getAllProducts();
      const p = allProducts.find(x => x.id === id);
      $('#name').value = p.name || '';
      $('#model').value = p.model || '';
      $('#notes').value = p.notes || '';
      if (document.getElementById('watt')) $('#watt').value = p.watt || '';
      if (document.getElementById('lumen')) $('#lumen').value = p.lumen || '';
      if (document.getElementById('eqType')) $('#eqType').value = p.type || '';
      $('#cutsheet').value = '';
      $('#cert').value = '';
      const prev=$('#photoPreview'); if (prev){ if (p.image && p.image.dataUrl){ prev.src=p.image.dataUrl; prev.classList.remove('hidden'); } else { prev.classList.add('hidden'); } }
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }

    async function deleteItem(id) {
      await deleteProduct(id);
      selectedIds.delete(String(id));
      const list = await getAllProducts();
      render(list);
      showToast('Product deleted','success');
    }

    async function triggerDownloadData(data, filename, mime='application/octet-stream') {
      let blob;
      try{
        if (data instanceof Blob) {
          blob = data;
        } else if (typeof data === 'string' && data.startsWith('data:')) {
          blob = dataURLToBlob(data);
        } else if (data instanceof Uint8Array || data instanceof ArrayBuffer) {
          blob = new Blob([data], { type: mime });
        } else {
          console.error('Unsupported data type for download');
          showToast('Unsupported data type for download','error');
          return;
        }
        const saved = await tryNativeSave(blob, filename);
        if (saved) return;
        const a = document.createElement('a');
        const url = URL.createObjectURL(blob);
        a.href = url; a.download = filename;
        try { document.body.appendChild(a); a.click(); a.remove(); }
        catch { showToast('Click to download '+filename); document.body.appendChild(a); a.textContent = 'Click to download '+filename; a.className = 'fixed bottom-20 right-4 bg-blue-600 text-white px-3 py-2 rounded-xl'; }
        setTimeout(() => URL.revokeObjectURL(url), 3000);
        showToast(`Saved ${filename}`,'success');
      }catch(err){ console.error(err); showToast('Download failed: '+(err?.message||err),'error'); }
    }

    async function downloadCutsheet(id) {
      const p = (await getAllProducts()).find(x => x.id === id);
      if (!p || !p.cutsheet) { showToast('No cutsheet available', 'error'); return; }
      const label = humanLabel(p);
      if (p.cutsheet.dataUrl) await triggerDownloadData(p.cutsheet.dataUrl, `${label}-cutsheet.pdf`, 'application/pdf');
      else if (p.cutsheet.data64) await triggerDownloadData(legacyBase64ToArrayBuffer(p.cutsheet.data64), `${label}-cutsheet.pdf`, 'application/pdf');
      else showToast('Cutsheet data missing', 'error');
    }

    async function downloadCert(id) {
      const p = (await getAllProducts()).find(x => x.id === id);
      if (!p || !p.cert) { showToast('No certification available', 'error'); return; }
      const label = humanLabel(p);
      const mime = p.cert.mime || 'application/octet-stream';
      const ext = mime === 'application/pdf' ? '.pdf' : (mime==='image/png'?'.png':'.jpg');
      if (p.cert.dataUrl) await triggerDownloadData(p.cert.dataUrl, `${label}-cert${ext}`, mime);
      else if (p.cert.data64) await triggerDownloadData(legacyBase64ToArrayBuffer(p.cert.data64), `${label}-cert${ext}`, mime);
      else showToast('Certification data missing', 'error');
    }

    async function combineProductDocs(p) {
      // Ensure the final order is ALWAYS: Cutsheet pages first, then Certification
      const { PDFDocument } = PDFLib;

      // Load cutsheet (always a PDF per input validation)
      const csBuf = p.cutsheet.dataUrl ? await dataURLToArrayBuffer(p.cutsheet.dataUrl)
                                       : legacyBase64ToArrayBuffer(p.cutsheet.data64);
      const csDoc = await PDFDocument.load(csBuf);

      // Create an output doc and copy cutsheet pages first
      const out = await PDFDocument.create();
      const csPages = await out.copyPages(csDoc, csDoc.getPageIndices());
      csPages.forEach(pg => out.addPage(pg));

      // Append certification after cutsheet
      if (p.cert.mime === 'application/pdf') {
        const ctBuf = p.cert.dataUrl ? await dataURLToArrayBuffer(p.cert.dataUrl)
                                     : legacyBase64ToArrayBuffer(p.cert.data64);
        const ctDoc = await PDFDocument.load(ctBuf);
        const ctPages = await out.copyPages(ctDoc, ctDoc.getPageIndices());
        ctPages.forEach(pg => out.addPage(pg));
      } else {
        // Image cert -> embed on a single new page after cutsheet
        const imgBytes = p.cert.dataUrl ? new Uint8Array(await dataURLToArrayBuffer(p.cert.dataUrl))
                                        : new Uint8Array(legacyBase64ToArrayBuffer(p.cert.data64));
        let img;
        if (p.cert.mime === 'image/png') img = await out.embedPng(imgBytes);
        else img = await out.embedJpg(imgBytes);
        const { width, height } = img.size();
        const maxW = 595.28, maxH = 841.89; // A4-ish
        const scale = Math.min(maxW/width, maxH/height, 1);
        const page = out.addPage([maxW, maxH]);
        const dx = (maxW - width*scale)/2;
        const dy = (maxH - height*scale)/2;
        page.drawImage(img, { x: dx, y: dy, width: width*scale, height: height*scale });
      }

      return await out.save();
    }

    async function downloadCombined(id) {
      const p = (await getAllProducts()).find(x => x.id === id);
      if (!p || !p.cutsheet || !p.cert) { showToast('Both cutsheet and certification are required', 'error'); return; }
      const bytes = await combineProductDocs(p);
      const label = humanLabel(p);
      await triggerDownloadData(bytes, `${label}-combined.pdf`, 'application/pdf');
    }

    // ======= Bulk helpers =======
    async function mergePDFs(pdfByteArrays){
      const { PDFDocument } = PDFLib;
      const out = await PDFDocument.create();
      for (const bytes of pdfByteArrays){
        const src = await PDFDocument.load(bytes);
        const pages = await out.copyPages(src, src.getPageIndices());
        pages.forEach(p=>out.addPage(p));
      }
      return await out.save();
    }

    async function buildCutsheetsPDF(ids){
      const list = await getAllProducts();
      const chunks = [];
      for (const id of ids){
        const p = list.find(x=>x.id===id); if (!p || !p.cutsheet) continue;
        const buf = p.cutsheet.dataUrl ? await dataURLToArrayBuffer(p.cutsheet.dataUrl)
                                       : legacyBase64ToArrayBuffer(p.cutsheet.data64);
        chunks.push(new Uint8Array(buf));
      }
      if (!chunks.length) throw new Error('No cutsheets selected');
      return await mergePDFs(chunks);
    }

    async function buildCertsPDF(ids){
      const { PDFDocument } = PDFLib;
      const out = await PDFDocument.create();
      const list = await getAllProducts();
      for (const id of ids){
        const p = list.find(x=>x.id===id); if (!p || !p.cert) continue;
        if (p.cert.mime === 'application/pdf'){
          const buf = p.cert.dataUrl ? await dataURLToArrayBuffer(p.cert.dataUrl)
                                     : legacyBase64ToArrayBuffer(p.cert.data64);
          const src = await PDFDocument.load(buf);
          const pages = await out.copyPages(src, src.getPageIndices());
          pages.forEach(pg=>out.addPage(pg));
        } else {
          // Convert image to a single-page PDF
          const page = out.addPage([595.28, 841.89]);
          const imgBytes = p.cert.dataUrl ? new Uint8Array(await dataURLToArrayBuffer(p.cert.dataUrl))
                                          : new Uint8Array(legacyBase64ToArrayBuffer(p.cert.data64));
          let img;
          if (p.cert.mime === 'image/png') img = await out.embedPng(imgBytes);
          else img = await out.embedJpg(imgBytes);
          const { width, height } = img.size();
          const scale = Math.min(595.28/width, 841.89/height, 1);
          const dx = (595.28 - width*scale)/2; const dy = (841.89 - height*scale)/2;
          page.drawImage(img, { x: dx, y: dy, width: width*scale, height: height*scale });
        }
      }
      const bytes = await out.save();
      if (!out.getPageCount()) throw new Error('No certs selected');
      return bytes;
    }

    async function buildCombinedPDF(ids){
      const chunks = [];
      const list = await getAllProducts();
      for (const id of ids){
        const p = list.find(x=>x.id===id); if (!p || !p.cutsheet || !p.cert) continue;
        const combined = await combineProductDocs(p);
        chunks.push(combined);
      }
      if (!chunks.length) throw new Error('No products with both docs selected');
      return await mergePDFs(chunks);
    }

    // =============================
    // Events
    // =============================
    $('#productForm').addEventListener('submit', handleSave);
    $('#cancelEdit').addEventListener('click', (e) => { e.preventDefault(); resetForm(); });
    $('#search').addEventListener('input', async () => render(await getAllProducts()));
    $('#typeFilter').addEventListener('change', async () => render(await getAllProducts()));
    $('#clearAllBtn').addEventListener('click', async () => { 
        // Removed confirm() as it blocks execution in an iframe.
        // Be careful! This will delete all products immediately.
        if (true) { // Was: if (confirm(...))
            await clearAllProducts();
            selectedIds.clear(); 
            render([]); 
            showToast('All products deleted', 'success');
        }
    });

    $('#exportJsonBtn').addEventListener('click', async () => {
      try{
        const json = JSON.stringify(await getAllProducts(), null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const now = new Date(); const pad=n=>String(n).padStart(2,'0');
        const fname = `products-${now.getFullYear()}${pad(now.getMonth()+1)}${pad(now.getDate())}-${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}.json`;
        triggerDownloadData(blob, fname, 'application/json');
      }catch(err){ console.error(err); showToast('Export failed: '+(err?.message||err),'error'); }
    });

    $('#importJson').addEventListener('change', async (e) => {
      const file = e.target.files[0]; if (!file) return;
      const text = await file.text();
      try { 
          const parsed = JSON.parse(text); 
          if (Array.isArray(parsed)) { 
            const normalized = parsed.map(normalizeProduct);
            await importProducts(normalized); 
            // --- CHANGE: Render all products and update toast message for merge ---
            render(await getAllProducts()); 
            showToast(`Imported/updated ${normalized.length} products.`, 'success');
            // --- END CHANGE ---
          } else { 
            showToast('Invalid JSON format', 'error'); 
          } 
      }
      catch (err) { console.error(err); showToast('Failed to parse JSON: '+(err?.message||err),'error'); }
      e.target.value = '';
    });

    // Row actions and selection
    $('#rows').addEventListener('click', async (e) => {
      if (e.target.closest('button')) e.preventDefault();
      const cb = e.target.closest('input.rowSel');
      if (cb){
        const id = cb.getAttribute('data-id');
        if (cb.checked) selectedIds.add(id); else selectedIds.delete(id);
        updateBulkUI();
        return;
      }
      // Handler for image modal
      const img = e.target.closest('img[data-act="view-img"]');
      if (img) {
        e.preventDefault();
        const id = img.getAttribute('data-id');
        const p = (await getAllProducts()).find(x => x.id === id);
        if (p && p.image?.dataUrl) {
          $('#modalImage').src = p.image.dataUrl;
          $('#imageModal').classList.remove('hidden');
        }
        return; // Stop further processing
      }
      const btn = e.target.closest('button'); if (!btn) return;
      const id = btn.getAttribute('data-id');
      const act = btn.getAttribute('data-act');
      try {
        if (act === 'edit') startEdit(id);
        else if (act === 'del') { 
          deleteItem(id); // Removed confirm() as it blocks execution in an iframe
        }
        else if (act === 'dl-cs') await downloadCutsheet(id);
        else if (act === 'dl-cert') await downloadCert(id);
        else if (act === 'dl-combined') await downloadCombined(id);
      } catch (err) { console.error(err); showToast('Operation failed: ' + (err?.message || err), 'error'); }
    });

    // Master select
    $('#selAll').addEventListener('change', () => {
      const visible = $$('#rows input.rowSel');
      const check = $('#selAll').checked;
      visible.forEach(cb => { cb.checked = check; const id = cb.getAttribute('data-id'); if (check) selectedIds.add(id); else selectedIds.delete(id); });
      updateBulkUI();
    });

    // Bulk buttons
    $('#bulkCutsheets').addEventListener('click', async ()=>{
      try { const bytes = await buildCutsheetsPDF(Array.from(selectedIds)); await triggerDownloadData(bytes, 'selected-cutsheets.pdf', 'application/pdf'); }
      catch(err){ showToast(err?.message||String(err),'error'); }
    });
    $('#bulkCerts').addEventListener('click', async ()=>{
      try { const bytes = await buildCertsPDF(Array.from(selectedIds)); await triggerDownloadData(bytes, 'selected-certs.pdf', 'application/pdf'); }
      catch(err){ showToast(err?.message||String(err),'error'); }
    });
    $('#bulkCombined').addEventListener('click', async ()=>{
      try { const bytes = await buildCombinedPDF(Array.from(selectedIds)); await triggerDownloadData(bytes, 'selected-combined.pdf', 'application/pdf'); }
      catch(err){ showToast(err?.message||String(err),'error'); }
    });

    // =============================
    // Tests (keep existing; add a few more)
    // =============================
    function logTest(msg) { const el = $('#testLog'); el.textContent += msg + '\n'; }

    async function runTests() {
      $('#testLog').textContent = '';
      logTest('Running tests...');
      const testIds = ['T1', 'T2', 'T_DEL'];
      try {
        const { PDFDocument } = PDFLib;
        // Build tiny PDF for cutsheet
        const pdf = await PDFDocument.create(); pdf.addPage([200, 200]);
        const csBytes = await pdf.save();
        const csBlob = new Blob([csBytes], { type: 'application/pdf' });
        const csUrl = URL.createObjectURL(csBlob);
        const csDataUrl = await (await fetch(csUrl)).blob().then(b => new Promise(r=>{ const fr=new FileReader(); fr.onload=()=>r(fr.result); fr.readAsDataURL(b); }));
        URL.revokeObjectURL(csUrl);

        // PNG for cert
        const canvas = document.createElement('canvas'); canvas.width = 50; canvas.height = 50; const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#ddd'; ctx.fillRect(0,0,50,50); ctx.fillStyle = '#000'; ctx.fillRect(10,10,30,30);
        const certDataUrl = canvas.toDataURL('image/png');
        const photoDataUrl = canvas.toDataURL('image/png');

        // Create two products; second has cert as a PDF page
        const pdf2 = await PDFDocument.create(); pdf2.addPage([300, 300]);
        const certPdfBytes = await pdf2.save();
        const certPdfBlob = new Blob([certPdfBytes], { type: 'application/pdf' });
        const certPdfUrl = URL.createObjectURL(certPdfBlob);
        const certPdfDataUrl = await (await fetch(certPdfUrl)).blob().then(b => new Promise(r=>{ const fr=new FileReader(); fr.onload=()=>r(fr.result); fr.readAsDataURL(b); }));
        URL.revokeObjectURL(certPdfUrl);

        const p1 = { id: 'T1', name: 'Bulk One', model: 'B-1', type: 'Lighting', created_at: Date.now(), updated_at: Date.now(),
          cutsheet: { filename: 'cs1.pdf', mime: 'application/pdf', dataUrl: csDataUrl },
          cert: { filename: 'cert1.png', mime: 'image/png', dataUrl: certDataUrl },
          image: { filename: 'p1.png', mime: 'image/png', dataUrl: photoDataUrl },
          watt: '50', lumen: '5000' };
        const p2 = { id: 'T2', name: 'Bulk Two', model: 'B-2', type: 'HVAC', created_at: Date.now(), updated_at: Date.now(),
          cutsheet: { filename: 'cs2.pdf', mime: 'application/pdf', dataUrl: csDataUrl },
          cert: { filename: 'cert2.pdf', mime: 'application/pdf', dataUrl: certPdfDataUrl },
          image: { filename: 'p2.png', mime: 'image/png', dataUrl: photoDataUrl },
          watt: '25', lumen: '2500' };
        
        await saveProduct(p1);
        await saveProduct(p2);
        render(await getAllProducts());
        logTest('✓ Seeded two products for bulk tests');

        // Combined for a single product
        const singleCombined = await combineProductDocs(p1);
        const singleDoc = await PDFDocument.load(singleCombined);
        if (singleDoc.getPageCount() >= 2) logTest('✓ Single combine OK');
        else throw new Error('Single combine failed');

        // Bulk cutsheets (2 cutsheet PDFs => 2+ pages)
        const bulkCs = await buildCutsheetsPDF(['T1','T2']);
        const bulkCsDoc = await PDFDocument.load(bulkCs);
        if (bulkCsDoc.getPageCount() >= 2) logTest('✓ Bulk cutsheets merged');
        else throw new Error('Bulk cutsheets page count < 2');

        // Bulk certs (1 PNG -> page, 1 PDF -> page) => >= 2 pages
        const bulkCt = await buildCertsPDF(['T1','T2']);
        const bulkCtDoc = await PDFDocument.load(bulkCt);
        if (bulkCtDoc.getPageCount() >= 2) logTest('✓ Bulk certs merged');
        else throw new Error('Bulk certs page count < 2');

        // Bulk combined across products => >= 4 pages (each combined >=2)
        const bulkComb = await buildCombinedPDF(['T1','T2']);
        const bulkCombDoc = await PDFDocument.load(bulkComb);
        if (bulkCombDoc.getPageCount() >= 4) logTest('✓ Bulk combined merged');
        else throw new Error('Bulk combined page count < 4');

        // Extra tests (added): watt/lumen render + filter by type
        document.getElementById('typeFilter').value = 'Lighting'; render(await getAllProducts());
        const firstName = document.querySelector('#rows tr td:nth-child(2) .font-medium')?.textContent?.trim();
        if (firstName === 'Bulk One') logTest('✓ Type filter applied (Lighting)');
        const wattText = document.querySelector('#rows tr td:nth-child(2) .text-xs')?.textContent?.includes('50 W');
        if (wattText) logTest('✓ Watt/Lumen rendered');
        document.getElementById('typeFilter').value = ''; // reset filter

        // Delete test
        const pDel = { id: 'T_DEL', name: 'Temp', created_at: Date.now(), updated_at: Date.now() };
        await saveProduct(pDel);
        render(await getAllProducts());
        await deleteItem('T_DEL');
        if (!(await getAllProducts()).some(x=>x.id==='T_DEL')) logTest('✓ Delete removes item');
        else throw new Error('Delete failed');

        logTest('All tests passed.');
      } catch (err) {
        logTest('Test failure: ' + (err?.message || err));
      } finally {
        // Clean up test items
        try {
            for (const id of testIds) { await deleteProduct(id); }
            logTest('✓ Test cleanup complete.');
            render(await getAllProducts());
        } catch (err) {
            logTest('! Test cleanup failed: ' + err.message);
        }
      }
    }

    document.getElementById('runTests').addEventListener('click', runTests);

    // =============================
    // Init
    // =============================
    async function mainInit() {
        document.getElementById('y').textContent = new Date().getFullYear();
        document.getElementById('photo')?.addEventListener('change', async (e)=>{ const f=e.target.files[0]; const img=$('#photoPreview'); if (!f){ img?.classList.add('hidden'); return;} if(!['image/png','image/jpeg'].includes(f.type)){ showToast('Image must be PNG or JPG','error'); e.target.value=''; img?.classList.add('hidden'); return;} const dataUrl = await readFileAsDataURL(f); if (img){ img.src=dataUrl; img.classList.remove('hidden'); } });

        // Event listeners for the modal. Since the modal HTML is *above* the script now, 
        // these should be found, but we keep the null checks for robustness.
        const closeModalBtn = $('#closeModal');
        if (closeModalBtn) {
            closeModalBtn.addEventListener('click', () => {
              $('#imageModal')?.classList.add('hidden');
              $('#modalImage').src = ''; // Clear src
            });
        }
        
        const imageModalEl = $('#imageModal');
        if (imageModalEl) {
            imageModalEl.addEventListener('click', (e) => {
                // Close if clicking the background overlay
                if (e.target.id === 'imageModal') {
                    imageModalEl.classList.add('hidden');
                    $('#modalImage').src = ''; // Clear src
                }
            });
        }

        await initDB();
        
        // Check if migration is needed
        if (!localStorage.getItem(MIGRATION_KEY)) {
            const oldData = _legacyLoadAllFromLocalStorage();
            if (oldData.length > 0) {
                showToast(`Migrating ${oldData.length} products to new storage...`);
                try {
                    const normalized = oldData.map(normalizeProduct);
                    await importProducts(normalized); // Clears and adds
                    localStorage.removeItem(LS_KEY); // Remove old data
                    localStorage.setItem(MIGRATION_KEY, 'true');
                    showToast('Migration complete!', 'success');
                } catch (err) {
                    console.error('Migration failed:', err);
                    showToast('Data migration failed. See console.', 'error');
                }
            } else {
                // No old data, just mark as migrated
                localStorage.setItem(MIGRATION_KEY, 'true');
            }
        }
        
        // Initial render from IDB
        try {
            const products = await getAllProducts();
            render(products);
        } catch (err) {
            console.error('Failed to load initial products:', err);
            showToast('Could not load products from database.', 'error');
        }
    }

    // --- FIX: Ensure mainInit runs after the HTML structure is loaded ---
    // The modal HTML is now placed before this script, but using DOMContentLoaded is the safest practice.
    document.addEventListener('DOMContentLoaded', mainInit);
  </script>
</body>
</html>
